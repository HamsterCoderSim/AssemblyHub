# 3.1.1 第一个汇编语言程序

:one:**汇编语言的`hello world`**

现在来看一个最简单的汇编语言程序，就是汇编语言的`hello world`。但是这个程序不能运行，只是单纯用来看一下。

```assembly
main PROC
	mov eax,5
	add eax,6
	
	INVOKE ExitProcess,0		; 程序结束
main ENDP
```

对上述代码进行解释：

- 第1行开始`main`主程序，是程序的入口
- 第2行将数字5送入eax寄存器
- 第3行把6加到EAX的值上，得到新的值11
- 第5行调用Windows系统函数`ExitProcess`停止程序，并且把控制权交还给操作系统
- 第6行是主程序结束的标记

:two:**添加一个变量**

在高级语言中，我们通常会定义变量，例如`int a=0`，在汇编语言中同样也可以定义变量

```assembly
.data						; 此为数据区
sum DWORD 0			; 定义名为sum的变量

.code						; 此为代码区
main PROC
	mov eax,5
	add eax,6
	mov sum,eax
	
	INVOKE ExitProcess,0		; 程序结束
main ENDP
```

上述代码中的第2行定义了一个双字（32位）大小的`sum`变量，使用的是关键字`DWORD`（表示doubleword，即双字）。

同样地，上述代码也定义了**数据段**和**代码段**，以后还要定义第3种段**堆栈**。

# 3.1.2 整数常量

:one: 整型常量在不加基数的情况下默认是十进制，如果不是十进制的需要加基数指明进制单位。例如

```assembly
26							; 十进制
26H							; 16进制
11011101b				; 2进制
0A3H						; 16进制，注意以字母开头的16进制数需要在开头加上0，防止被汇编器解释为标识符
```

上述数据中的`H`表示16进制，`b`表示2进制，下表是可能的基数值

| 基数  |    进制大小    |
| :---: | :------------: |
|   h   |    十六进制    |
| q / o |     八进制     |
|   d   |     十进制     |
|   b   |     二进制     |
|   r   |    编码实数    |
|   t   | 十进制（备用） |
|   y   | 二进制（备用） |

:two: 通过在整型常量前添加`-`号来区分整形常量的正负

```assembly
-26					; -26
-26H				; 16进制，并且为复数
+15					; 加不加+都可表示为正数
```

# 3.1.3 整形常量表达式

整形常量表达式是一个表达式，什么是表达式呢？

`a+b`就是一个**表达式**，其中**包括**

- **整形常量**`a`和`b`
- **算术运算符**`+`

下表列出了所有的算数运算符和它们的优先级，其中1代表最高优先级，4代表最低优先级。

| 算数运算符 |         名称         | 优先级 |
| :--------: | :------------------: | :----: |
|    ( )     |        圆括号        |   1    |
|    +, -    | 一元加、减（正负号） |   2    |
|    *, /    |         乘除         |   3    |
|    MOD     |         取模         |   3    |
|    +, -    |        加、减        |   4    |

下面看几个简单的例子

```assembly
4 + 5 * 2

12 - 1 MOD 5

-5 + 2
```

# 3.1.4 实数常量

暂时不会用到

# 3.1.5 字符常量

字符常量是用单引号或双引号包含的一个字符，汇编器保存的是该字符二进制ASCII码的数值。

```assembly
; 以下两个字符常量等价，在内存中存放的为65或41H
'A'
"A"
```

# 3.1.6 字符串常量

字符串常量是用**单引号或双引号**包含的一个字符（含空格符），例如

```assembly
; 'ABCD'在内存中存放4个字节：41h, 42h, 43h, 44h

'ABCD'
"EFGH"
```

# 3.1.7 保留字

保留字就像是高级语言中的关键字，保留字是没有大小写之分的，以下就是保留字的几种类型。

![image-20210926165715272](http://gujigujicat.com/image-20210926165715272.png)

# 3.1.8 标识符

标识符就是定义的变量的名字

# 3.1.9 伪指令

伪指令是嵌入源代码中的命令，由汇编器识别并且执行。伪指令执行的功能如下：

- 定义变量、宏和子程序
- 为内存段分配名称，执行许多其他与汇编器相关的日常任务

:one: 定义变量：伪指令定义变量

拿个例子来看，下面的`DWORD`和`mov`伪指令

```assembly
myVar DWORD 26			; DWORD伪指令告诉汇编器在程序中为一个双字变量保留空间
mov eax,myVar				; MOV指令在运行时执行，将myVar的内容复制到eax寄存器中
```

不同的处理器，其指令集不同，伪指令也不相同；尽管Intel处理器的所有汇编器有相同的指令集，但是其伪指令也通常不相同。

:two: 定义段：伪指令定义程序区段

汇编器伪指令的一个重要功能就是定义程序区段，也称为段。程序中段通常有不同的作用，例如数据段、代码段等等。我们用伪指令开辟对应的段，例如

```assembly
.data			; 开辟数据段

.code			; 开辟代码段

.stack 100h		; 定义运行时堆栈，设置其大小
```

# 3.1.10 指令

指令是一种语句，在程序汇编编译时变得可执行。汇编器将指令翻译成机器语言字节，运行时由CPU加载和运行。一条指令可以有以下4个组成部分

![image-20210926171037316](http://gujigujicat.com/image-20210926171037316.png)

:one: 标号

标号是一种标识符，是指令和数据的位置标记。比如，下面的`target`就是代表一段程序的位置

```assembly
target:
	mov ax,bx
	add ax,10
```

我们用一个`jmp`指令跳转到`target`对应的位置`jmp target`。

:two: 指令助记符

下面是几个指令助记符

| 助记符 | 说明                       |
| ------ | -------------------------- |
| MOV    | 传送数值                   |
| ADD    | 两个数值相加               |
| SUB    | 从一个数值中减去另一个数值 |
| MUL    | 两个数值相乘               |
| JMP    | 跳转到一个新位置           |
| CALL   | 调用一个子程序             |

:three: 操作数

操作数是指令输入输出的数值。下表是常见的操作数

| 示例  | 操作数类型 |
| ----- | ---------- |
| 96    | 整数常量   |
| 2+4   | 整数表达式 |
| eax   | 寄存器     |
| count | 内存       |

现在来看几个例子

```assembly
inc eax						; eax是操作数
mov count,ebx			; 将ebx中的值传递给count

imul eax,ebx,5		; 将ebx与5相乘，结果放到eax中去
```

:four: 注释

- 单行注释，使用`;`注释
- 多行注释，用`comment`伪指令和一个用户定义的符号开始，然后到用户定义的符号截止。

例子：

```assembly
; 这是单行注释

comment $
	这是多行注释
	$符号是自己定义的，随便换
$
```

:five: `NOP`空操作指令

他什么都不做，但是在程序控件中占有一个字节。
